<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js - pointerlock controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      html, body {
        width: 100%;
        height: 100%;
      }
      body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
        font-family: arial;
      }
      #blocker {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
      }
      #instructions {
        width: 100%;
        height: 100%;
        display: -webkit-box;
        display: -moz-box;
        display: box;
        -webkit-box-orient: horizontal;
        -moz-box-orient: horizontal;
        box-orient: horizontal;
        -webkit-box-pack: center;
        -moz-box-pack: center;
        box-pack: center;
        -webkit-box-align: center;
        -moz-box-align: center;
        box-align: center;
        color: #ffffff;
        text-align: center;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <script src="../third_party/three.js/three.js"></script>
    <script src="../third_party/controls/PointerLockControls.js"></script>
    <script src="../dist/three.ar.js"></script>
    <script src="../third_party/three.js/DRACOLoader.js"></script>
    <script src="../third_party/three.js/GLTFLoader.js"></script>
  <script id="fragmentShader" type="shader">
  precision mediump float;
  precision mediump int;

  varying vec3 vPosition;
  varying vec3 vNormal;
  varying vec2 vUv;
  varying vec3 vVelocity;

  void main() {
    vec2 uv = vUv;
    uv *= 2.0;
    uv -= 1.0;
    float aa = 1.0 - abs( uv.y );
    aa = smoothstep( 0.0, 0.05, aa );
    gl_FragColor = vec4( vNormal, aa );
  }
  </script>
  <script id="vertexShader" type="shader">
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat3 normalMatrix;

    attribute vec3 position;
    attribute vec3 normal;
    attribute vec2 uv;
    attribute vec3 velocity;

    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec3 vVelocity;

    void main()
    {
        vPosition = position;
        vNormal = normal;
        vUv = uv;
        vVelocity = velocity;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }

  </script>
    <div id="blocker">

      <div id="instructions">
        <span style="font-size:40px">Click to play</span>
        <br />
        (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
      </div>

    </div>

    <script>
      var camera, scene, renderer, controls;
      var mixer = null;
      var clock = new THREE.Clock();
      /*
      *  실제 ar로 할 때 주의사항
      *  PointerLockControls 제거, three.ar.js로 이용
      *  거리 관련 const는 모두 재설정필요
      *  controls.getObject().position, camera.positiond으로 변경
      */

      var objects = [];
      var raycaster;
      var blocker = document.getElementById( 'blocker' );
      var instructions = document.getElementById( 'instructions' );
      // http://www.html5rocks.com/en/tutorials/pointerlock/intro/
      var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
      if ( havePointerLock ) {
        var element = document.body;
        var pointerlockchange = function ( event ) {
          if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
            controlsEnabled = true;
            controls.enabled = true;
            blocker.style.display = 'none';
          } else {
            controls.enabled = false;
            blocker.style.display = 'block';
            instructions.style.display = '';
          }
        };
        var pointerlockerror = function ( event ) {
          instructions.style.display = '';
        };
        // Hook pointer lock state change events
        document.addEventListener( 'pointerlockchange', pointerlockchange, false );
        document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
        document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
        document.addEventListener( 'pointerlockerror', pointerlockerror, false );
        document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
        document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
        instructions.addEventListener( 'click', function ( event ) {
          instructions.style.display = 'none';
          // Ask the browser to lock the pointer
          element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
          element.requestPointerLock();
        }, false );
      } else {
        instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
      }

      var controlsEnabled = false;
      var moveForward = false;
      var moveBackward = false;
      var moveLeft = false;
      var moveRight = false;
      var canJump = false;
      var prevTime = performance.now();
      var velocity = new THREE.Vector3();
      var direction = new THREE.Vector3();

			updateFunc = [];
			update = updateGenerator(updateFunc);
      init().then((d) => {
				console.log(d);
				update();
			});

      function init() {

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xffffff );
        scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
        var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
        light.position.set( 0.5, 1, 0.75 );
        scene.add( light );
        controls = new THREE.PointerLockControls( camera );
        scene.add( controls.getObject() );

        var onKeyDown = function ( event ) {
          switch ( event.keyCode ) {
            case 38: // up
            case 87: // w
              moveForward = true;
              break;
            case 37: // left
            case 65: // a
              moveLeft = true; break;
            case 40: // down
            case 83: // s
              moveBackward = true;
              break;
            case 39: // right
            case 68: // d
              moveRight = true;
              break;
            case 32: // space
              if ( canJump === true ) velocity.y += 150;
              canJump = false;
              break;
            case 70: // f
              drawing = true;
              break;
          }
        };
        var onKeyUp = function ( event ) {
          switch( event.keyCode ) {
            case 38: // up
            case 87: // w
              moveForward = false;
              break;
            case 37: // left
            case 65: // a
              moveLeft = false;
              break;
            case 40: // down
            case 83: // s
              moveBackward = false;
              break;
            case 39: // right
            case 68: // d
              moveRight = false;
              break;
            case 70: //f
              drawing = false;
              stroke.length = 0;
              strokeIndex += 1;
              break;
          }
        };
        document.addEventListener( 'keydown', onKeyDown, false );
        document.addEventListener( 'keyup', onKeyUp, false );

        raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

        // floor
        var floorGeometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
        floorGeometry.rotateX( - Math.PI/2 );

        // 정점 섞기
        for ( var i = 0, l = floorGeometry.vertices.length; i < l; i ++ ) {
          var vertex = floorGeometry.vertices[ i ];
          vertex.x += Math.random() * 20 - 10;
          vertex.y += Math.random() * 2;
          vertex.z += Math.random() * 20 - 10;
        }

        var floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.NoColors } );
        floorMaterial.opacity = 0;
        floorMaterial.transparent = true;
        var floor = new THREE.Mesh( floorGeometry, floorMaterial );
        scene.add( floor );

        // objects
        var boxGeometry = new THREE.BoxGeometry( 20, 20, 20 );
        for ( var i = 0, l = boxGeometry.faces.length; i < l; i ++ ) {
          var face = boxGeometry.faces[ i ];
          face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
          face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
          face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        }

        config = {
          gltfPath: '../model/dragon/scene.gltf',
          decoderPath : './third_party/draco/',
          GLTFLoader: THREE.GLTFLoader,
          DRACOLoader: THREE.DRACOLoader
        };

        THREE.ARUtils.newLoadModel(config).then(function(gltf) {
          var dragon = gltf.scene;
          dragon.scale.set(100,100,100);
          mixer = new THREE.AnimationMixer( dragon );
          var animations = gltf.animations;
          if ( animations && animations.length ) {

            // for ( var i = 0; i < animations.length; i ++ ) {
              var animation = animations[ 0 ];
              console.log(animation)
              // There's .3333 seconds junk at the tail of the Monster animation that
              // keeps it from looping cleanly. Clip it at 3 seconds
               animation.duration = 0.8;

            var action = mixer.clipAction( animation );
            action.setLoop(THREE.LoopOnce, 1);
            console.log(action);
            action.play();

            // }
          }

          scene.add(dragon);
          // clip = gltf.animations[1];
          // var action = mixer.existingAction( clip );
          // console.log(action)
          // action.play();




      // gltf.animations; // Array<THREE.AnimationClip>
      // gltf.scene; // THREE.Scene
      // gltf.scenes; // Array<THREE.Scene>
      // gltf.cameras; // Array<THREE.Camera>
      // gltf.asset; // Object
        });

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        //
        window.addEventListener( 'resize', onWindowResize, false );

				return new Promise((resolve, reject) => resolve("resolve"));

      } // end init()


      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }


			function updateGenerator(updateFunc) {
		 	 var args = updateFunc;

		 	 animate = function() {
		 	  // Clears color from the frame before rendering the camera (arView) or scene.

				    	renderer.clearColor();
	            if (mixer) mixer.update(clock.getDelta());
							args.forEach((f)=>{console.log(f)})
		        	requestAnimationFrame( animate );
			        if ( controlsEnabled === true ) {

				          raycaster.ray.origin.copy( controls.getObject().position );
				          raycaster.ray.origin.y -= 10;
				          var intersections = raycaster.intersectObjects( objects );
				          var onObject = intersections.length > 0;
				          var time = performance.now();
				          var delta = ( time - prevTime ) / 1000;
				          velocity.x -= velocity.x * 10.0 * delta;
				          velocity.z -= velocity.z * 10.0 * delta;
				          velocity.y -= 9.8 * 50.0 * delta; // 100.0 = mass
				          direction.z = Number( moveForward ) - Number( moveBackward );
				          direction.x = Number( moveLeft ) - Number( moveRight );
				          direction.normalize(); // this ensures consistent movements in all directions
				          if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
				          if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
				          if ( onObject === true ) {
				            velocity.y = Math.max( 0, velocity.y );
				            canJump = true;

				          }
				          controls.getObject().translateX( velocity.x * delta );
				          controls.getObject().translateY( velocity.y * delta );
				          controls.getObject().translateZ( velocity.z * delta );
				          if ( controls.getObject().position.y < 10 ) {
				            velocity.y = 0;
				            controls.getObject().position.y = 10;
				            canJump = true;

				          }
				          prevTime = time;
				        }
				      // Render our three.js virtual scene
			        renderer.clearDepth();
				      renderer.render( scene, camera );
		 	}

			return animate
		}

    </script>
  </body>
</html>
